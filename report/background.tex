%!TEX root = ./report.tex
\section{Background}
\label{sec:background}
\subsection{Coq}
\todo{Revise this section}
Coq is a interactive theorem prover for managing formal proofs. It is a language that implements the program specification language Gallina. Due to Gallinas base in CiC (Calculus of Inductive Constructions)\todo{Insert ref to CiC}, Coq implements both higher-order logics and a richly-typed functional programming language.

\subsection{Imp}
As previously mentioned, Imp is a simple imperative programming language studied in the electronic book ``Software Foundations'' \footnote{Not to be confused with Irons IMP language or the Edinburgh IMP language.} implemented in Coq. The language includes some core features of widely used programming languages such as C, and certain properties about the language as a whole have been proven. This helps verification of programs written in Imp, as the precise definition of Imp can be used to formally prove that a certain program satisfies particular specifications of their behavior. 

At the core of the language is arithmetics and boolean expressions, which can be assigned to variables. The value of these variables at a point of execution is represented by a state, which is a partially applied function $id \rightharpoonup value$. The language has a command for assignment of variables. It furthermore has control flow statements for conditioning, looping, and sequencing. To be able to reason about these commands, assertions are used to make claims about a particular state of a program during execution. These assertions are expressed as $state \rightharpoonup Prop$, and are used in hoare triples to reason about the commands.
\[
    \infrule[Assignment]{}{
      	\triple
      		{Q\subst a X} 
      		{\;\cassign {X} {a}\;}
	  		{Q}
    }
    \;\;\;\;\;\;\;\;
    \infrule[Skip]{}{
      	\triple
      		{P} 
      		{\; \mathbf{SKIP} \;}
	  		{P}
    }
\]

\[
    \infrule[Sequence]{
    	\triple
      		{P} 
      		{\;c1\;}
	  		{Q}
	  		\;\;
	  	\triple
      		{Q} 
      		{\;c2\;}
	  		{R}
    }{
      	\triple
      		{P} 
      		{\;c1;c2\;}
	  		{R}
    }
    \;\;\;\;\;\;\;\;
    \infrule[While]{
    	\triple
      		{P \land b} 
      		{\; c \;}
	  		{P}
    }{
      	\triple
      		{P} 
      		{\; \mathbf{WHILE}\;{b}\;\mathbf{DO}\;{c}\;\mathbf{END} \;}
	  		{P \land \neg b}
    }
\]
\[
    \infrule[If]{
    	\triple
      		{P \land b} 
      		{\; c1 \;}
	  		{Q}
	  	\;\;
	  	\triple
      		{P \land \neg b} 
      		{\; c2 \;}
	  		{Q}
    }{
      	\triple
      		{P} 
      		{\;\mathbf{IF}\;{b}\;\mathbf{THEN}\;{c1}\;\mathbf{ELSE}\;{c2}\;\mathbf{FI} \;}
	  		{Q}
    }
\]

As with the rest of the project, Imp deals with partial correctness. It is important to note that the Imp languages worked on in this project is the one defined up to the Hoare Logic chapter\footnote{http://www.itu.dk/courses/SASP/F2013/Hoare.html}, thus things like the type checker is not included. 


 \input{separation_logic}

%!TEX root = ./report.tex
The hoare triples for the new commands reason about the behaviour on in a local scope. Since we would like to be able to reason about more complex programs we need to be able to use these rules in a global perspective. As such we need to prove that the behaviour of our commands is the same in a local and global scope. For this we will use the frame rule:

\[
	\infrule{
		\triple
			{P}
			{\;c\;}
			{Q}
		}
		{
		\triple
			{P\;*\;R}
			{\;c\;}
			{Q\;*\;R}
		}
\]
\begin{center}
\textit{where no variable occurring free in R is modified by c.}
\end{center}

\[
	\infrule{
		\triple
			{P}
			{\;c\;}
			{Q}
		}
		{
		\triple
			{P\;*\;R}
			{\;c\;}
			{Q\;*\;(\exists vs.\;R\subst{vs}{modified\;by\;c})}
		}
\]
\begin{center}
\textit{where modified by c is the list of variables modified by the command c}
\end{center}


\todo{How to do side condition.}
\subsubsection{Safety Monotonicity}
In section \ref{sec:hoare_triple} we introduced safety to our hoare triples, as a way of ensuring that no commands that would result in a erroneous state could satisfy the triple. Thus far we have only reasoned about safety in a local scope, but with the globalization of our hoare triples we need to ensure safety monotonicity. This means that if executing a command c in a state with $\heap \; h'$  is safe, and $h'\;\heapsubop\;h$ then c must also be safe in a with $\heap \; h$.
\todo{How do we actually do this?}
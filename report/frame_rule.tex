%!TEX root = ./report.tex
\label{sec:frame_rule}
\paragraph{Frame Rule}
The hoare triples for the new commands only describe the effects the command has on the part of the mutable store it explicitly mentions. To make claims about more complex programs with effects outside just a local scope, we need to widen our perspective. We need to prove that the behaviour of our commands is the same regardless of the heap that we do not explicitly mention. For this we will use the frame rule as described by Yang and O'Hearn\,\cite{Yang02asemantic}.

\[
	\infrule{
		\triple
			{P}
			{\;c\;}
			{Q}
		}
		{
		\triple
			{P\;*\;R}
			{\;c\;}
			{Q\;*\;R}
		}
\]
\begin{center}
\textit{where no variable occurring free in R is modified by c.}
\end{center}

As stated above this rule only holds in the event that c does not modify $R$. This means that any time this rule is used to prove a property of a program, it would have to be proven that the command does not modify $R$. To avoid this, we alter the frame rule slightly, to accommodate for this. If c does not modify $R$, then the same values are in $R$ before and after the execution of c. Therefore, in the case that c does modify $R$, there must exist a list of values that when substituted with the variables that have been modified by a given command, will recreate the original state. We can use this to construct a postcondition for the frame rule that will guarantee the side condition form the original frame rule. We formalize it as follows:

\[
	\infrule{
		\triple
			{P}
			{\;c\;}
			{Q}
		}
		{
		\triple
			{P\;*\;R}
			{\;c\;}
			{Q\;*\;(\exists vs.\;R\subst{vs}{modified\_by\;c})}
		}
\]

\paragraph{Safety Monotonicity}
In section \ref{sec:hoare_triple} we introduced safety to our hoare triples, as a way of ensuring that no commands that would result in a erroneous state could satisfy the triple. Thus far we have only reasoned about safety in a local scope, but with the globalization of our hoare triples we assume safety monotonicity. This means that if executing a command c in a state with $\heap \; h'$  is safe, and $h'\;\heapsubop\;h$ then c must also be safe in a with $\heap \; h$. This property follows from the frame rule.
\todo{Is this section accurate?}
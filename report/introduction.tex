%!TEX root = ./report.tex
\section{Introduction}
We investigate how to add shared mutable storage to an imperative programming language, Imp, and how to verify Imp programs involving such storage using separation logic.
\paragraph{}
Separation logic\,\cite{Reynolds02} is an extension of Hoare logic which is devised for local reasoning about shared, mutable data structures. Reasoning about shared data structures in classic Hoare logic is complicated by the fact that when developing programs, we often assume that data structures do not share memory, but when proving the same programs correct, we assume that they do and have to prove otherwise\,\cite{reynolds2008AnIntroductionTo}\todo{Add page number?}. Separation logic alleviates this situation by allowing us to specify a program in terms of the data storage it modifies, abstracting from the parts of the storage that are unaffected by the program. 
\paragraph{}
The Imp language is a simple imperative language, in which only \todo{some core functions} core constructs of full-fledged languages such and C and Java are defined. These include variable assignment, sequencing of commands, conditional statements, and while loops. It does not, however, have a mutable state, making most data structures unnecessarily complex to define and cumbersome to work with. Extending the language with a shared mutable state adds to the expressiveness of the language, but also requires an extension of the logic for verifying Imp programs.

\paragraph{Problem.}
The problem is twofold. It is 1) extending the intuitionistic Hoare logic in which Imp programs are verified with a separation logic and 2) defining new language constructs for the Imp language for manipulating the shared mutable state, defined as a heap, together with Hoare rules for these.


\paragraph{Contributions.}
Our contribution is a solution for the second part of the problem. We define syntax and semantics for the four essential contructs enabling utilization of a mutable state: read, write, allocation, and deallocation. To be able to reason about and prove programs written in the Imp language involving these constructs, we define Hoare rules for each of them. The soundness of these rules have been proven with Coq, an interactive theorem prover. \todo{do we actually define them?}Furthermore, we define and prove the frame rule and rules of consequence for use in correctness proofs of Imp programs.

\paragraph{Dependencies.}
For the first part of the problem, we rely heavily on the work on constructing separation logics from separation algebra done by Jesper Bengtson et al.\,\cite{BirkedalL:veroop-conf}, which will be introduced in Section \ref{sec:separation_logic}. For second part we use a reimplementation of maps using typeclasses by St√©phane Lescuyer\,\cite{CoqContainers} to model the heap. The language we are extending, Imp, is defined in ``Software Foundations''\,\cite{Pierce:SF}, which is also our source for certain simple, but useful theorems about booleans and arithmetics\,\cite{SfLib}.

\paragraph{Coq.}
For implementing new features, and proving these, we use the proof assistant Coq \cite{CoqIntro}. Coq can be used to express specifications and develop programs that fulfill these specifications, and an interactive proof assistant in which you can develop proofs in higher-order logics.

\paragraph{A motivating example: List reversal.}
Consider the classic example of in-place list reversal. While it may seem simple, it is a good example of a program that is not easily implemented in an imperative programming language without a mutable state. It involves non-trivial elements such as encoding the notion of a list, doing pointer arithmetics, and handling destructive updates to memory. To implement it requires a mutable state, a heap in our case, and to reason about it requires exact definitions of the behaviour of the heap. An Imp implementation is shown in Figure \ref{fig:list_reversal}.

Proving the correctness of programs involving a heap requires a rigorous formal system. In Section \ref{sec:background} we present such a system, separation logic, along with the basic Imp language on which we base our work. Section \ref{sec:programming_with_mutable_state} gives a definition of a heap. The exact definitions of the behaviour of the heap is provided in Section \ref{sec:heap_operations}, where syntax and semantics for the heap-manipulating operations are defined. Inference rules for proving the correctness of programs involving these operations are defined in Section \ref{sec:hoare_rules}, and auxiliary rules are provided in Section \ref{sec:frame_rule}. We reflect upon related work in Section \ref{sec:related_work} and conclude on our findings in Section \ref{sec:conclusion}.


\begin{figure}
\begin{coqdoccode}
\coqdocindent{7.00em}
\coqdocvar{Y} ::= (\coqdocvar{ANum} 0);\coqdoceol
\coqdocindent{7.00em}
\coqdocvar{WHILE} \coqdocvar{BNot} (\coqdocvar{BEq} (\coqdocvar{AId} \coqdocvar{X}) (\coqdocvar{ANum} 0)) \coqdocvar{DO}\coqdoceol
\coqdocindent{10.00em}
\coqdocvar{Z} <$\sim$ [ \coqdocvar{APlus} (\coqdocvar{AId} \coqdocvar{X}) (\coqdocvar{ANum} 1) ];\coqdoceol
\coqdocindent{10.00em}
[ \coqdocvar{APlus} (\coqdocvar{AId} \coqdocvar{X}) (\coqdocvar{ANum} 1) ] <$\sim$ (\coqdocvar{AId} \coqdocvar{Y});\coqdoceol
\coqdocindent{10.00em}
\coqdocvar{Y} ::= (\coqdocvar{AId} \coqdocvar{X});\coqdoceol
\coqdocindent{10.00em}
\coqdocvar{X} ::= (\coqdocvar{AId} \coqdocvar{Z})\coqdoceol
\coqdocindent{7.00em}
\coqdocvar{END}.\coqdoceol
\end{coqdoccode}
\caption{An implementation of list reversal in the extended Imp language.}
\label{fig:list_reversal}
\end{figure}
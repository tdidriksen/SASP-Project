%!TEX root = ./report.tex
\section{Introduction}
The Imp language is a simple imperative language used in the book ``Software Foundations''\,\cite{Pierce:SF} to help shed light on the area of software verification. It includes a few core features of full-fledged imperative languages such as C, but it does not allow the developer to use a mutable state. This means that working with most data structures is unnecessarily complex and cumbersome, or might even be impossible. This paper attempts to improve on this by introducing a mutable state, without minimizing the integrity of the Imp language.

\paragraph{Problem.}
We address the problem of adding shared mutable state to an imperative language, namely the Imp language, and reasoning about programs involving such states. The problem is complicated by the fact that the state is shared among data structures. As noted by Reynolds\,\cite{reynolds2008AnIntroductionTo}\todo{Add page number?}, the issue is that when we develop programs, we assume that data structures do not share memory, but when reasoning about the same programs logically, we assume that they do and have to prove otherwise. To overcome this difficulty, we adopt the notion of separation logic, which allows us to reason locally about programs that mutate shared memory. In order to make use of this mutable state from within the Imp language, we also have to add the appropriate commands.

Thus, the problem is twofold. It is 1) extending the intuitionistic Hoare logic, in which the Imp language is already defined, with a separation logic and 2) defining new language constructs for the Imp language for manipulating the shared mutable state, together with Hoare rules for these.

\paragraph{Contributions.}
Our contribution is a solution for the second part of the problem. We define syntax and semantics for the four essential contructs enabling utilization of a mutable state: read, write, allocation, and deallocation. To be able to reason about and prove programs written in the Imp language involving these constructs, we define Hoare rules for each of them. The soundness of these rules have been proven with Coq, an interactive theorem prover. \todo{do we actually define them?}Furthermore, we define and prove the frame rule and rules of consequence for use in correctness proofs of Imp programs.

\paragraph{Dependencies.}
For the first part of the problem, we rely heavily on the work on constructing separation logics from separation algebra done by Jesper Bengtson et al.\,\cite{BirkedalL:veroop-conf}, which will be introduced in Section \ref{sec:separation_logic}.

\todo{Something about other dependencies here, such as SfLib and Containers Library.}

\paragraph{A motivating example: List reversal.}
Consider the classic example of in-place list reversal. While it may seem simple, it is a good example of a program that is not easily implemented in an imperative programming language without a mutable state. It involves non-trivial elements such as encoding the notion of a list, doing pointer arithmetics, and handling destructive updates to memory. To implement it requires a mutable state, a heap in our case, and to reason about it requires exact definitions of the behaviour of the heap. An Imp implementation is shown in Figure \ref{fig:list_reversal}.

Proving the correctness of programs involving a heap requires a rigorous formal system. In Section \ref{sec:background} we present such a system, separation logic, along with the basic Imp language on which we base our work. Section \ref{sec:programming_with_mutable_state} gives a definition of a heap. The exact definitions of the behaviour of the heap is provided in Section \ref{sec:heap_operations}, where syntax and semantics for the heap-manipulating operations are defined. Inference rules for proving the correctness of programs involving these operations are defined in Section \ref{sec:hoare_rules}, and auxiliary rules are provided in Section \ref{sec:frame_rule}. We reflect upon related work in Section \ref{sec:related_work} and conclude on our findings in Section \ref{sec:conclusion}.


\begin{figure}
\begin{coqdoccode}
\coqdocindent{7.00em}
\coqdocvar{Y} ::= (\coqdocvar{ANum} 0);\coqdoceol
\coqdocindent{7.00em}
\coqdocvar{WHILE} \coqdocvar{BNot} (\coqdocvar{BEq} (\coqdocvar{AId} \coqdocvar{X}) (\coqdocvar{ANum} 0)) \coqdocvar{DO}\coqdoceol
\coqdocindent{10.00em}
\coqdocvar{Z} <$\sim$ [ \coqdocvar{APlus} (\coqdocvar{AId} \coqdocvar{X}) (\coqdocvar{ANum} 1) ];\coqdoceol
\coqdocindent{10.00em}
[ \coqdocvar{APlus} (\coqdocvar{AId} \coqdocvar{X}) (\coqdocvar{ANum} 1) ] <$\sim$ (\coqdocvar{AId} \coqdocvar{Y});\coqdoceol
\coqdocindent{10.00em}
\coqdocvar{Y} ::= (\coqdocvar{AId} \coqdocvar{X});\coqdoceol
\coqdocindent{10.00em}
\coqdocvar{X} ::= (\coqdocvar{AId} \coqdocvar{Z})\coqdoceol
\coqdocindent{7.00em}
\coqdocvar{END}.\coqdoceol
\end{coqdoccode}
\caption{An implementation of list reversal in the extended Imp language.}
\label{fig:list_reversal}
\end{figure}